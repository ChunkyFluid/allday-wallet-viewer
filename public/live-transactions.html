<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Live Transactions ‚Äì Chunky's NFLAD Viewer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="/header.css" />
    <style>
      :root {
        --bg-main: #050816;
        --bg-card: #101322;
        --border-subtle: rgba(255, 255, 255, 0.06);
        --text-main: #f9fafb;
        --text-muted: #9ca3af;
        --accent-purple: #6f42c1;
        --accent-blue: #007bff;
        --accent-cyan: #0dcaf0;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background: radial-gradient(circle at top, #1e293b 0, #020617 55%);
        color: var(--text-main);
      }

      main.app-main {
        max-width: 1400px;
        margin: 1.5rem auto 2.5rem;
        padding: 0 1.5rem;
      }

      .page-title {
        font-size: 1.5rem;
        font-weight: 700;
        margin-bottom: 0.5rem;
      }

      .page-subtitle {
        font-size: 0.9rem;
        color: var(--text-muted);
        margin-bottom: 1.5rem;
      }

      .controls {
        display: flex;
        gap: 1rem;
        margin-bottom: 1.5rem;
        flex-wrap: wrap;
        align-items: center;
      }

      .status-indicator {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.5rem 1rem;
        background: var(--bg-card);
        border: 1px solid var(--border-subtle);
        border-radius: 8px;
        font-size: 0.9rem;
      }

      .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: var(--text-muted);
        animation: pulse 2s infinite;
      }

      .status-dot.active {
        background: #22c55e;
      }

      .status-dot.error {
        background: #f97373;
        animation: none;
      }

      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
      }

      .btn {
        padding: 0.5rem 1rem;
        border-radius: 6px;
        border: 1px solid var(--border-subtle);
        background: var(--bg-card);
        color: var(--text-main);
        cursor: pointer;
        font-size: 0.9rem;
        transition: all 0.2s;
      }

      .btn:hover {
        border-color: var(--accent-blue);
        background: rgba(0, 123, 255, 0.1);
      }

      .btn-primary {
        background: var(--accent-blue);
        border-color: var(--accent-blue);
        color: white;
      }

      .btn-primary:hover {
        background: #0056b3;
      }

      .transactions-table {
        width: 100%;
        border-collapse: collapse;
        background: var(--bg-card);
        border-radius: 8px;
        overflow: hidden;
        border: 1px solid var(--border-subtle);
      }

      .transactions-table thead {
        background: rgba(111, 66, 193, 0.1);
      }

      .transactions-table th {
        padding: 0.75rem 1rem;
        text-align: left;
        font-size: 0.85rem;
        font-weight: 600;
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .transactions-table td {
        padding: 0.75rem 1rem;
        border-top: 1px solid var(--border-subtle);
        font-size: 0.9rem;
      }

      .transactions-table tbody tr {
        transition: background 0.2s;
      }

      .transactions-table tbody tr:hover {
        background: rgba(255, 255, 255, 0.03);
      }

      .transactions-table tbody tr.new {
        background: rgba(34, 197, 94, 0.1);
        animation: highlight 2s ease-out;
      }

      @keyframes highlight {
        0% { background: rgba(34, 197, 94, 0.3); }
        100% { background: rgba(34, 197, 94, 0.1); }
      }

      .event-type {
        display: inline-block;
        padding: 0.25rem 0.5rem;
        border-radius: 4px;
        font-size: 0.75rem;
        font-weight: 600;
        text-transform: uppercase;
      }

      .event-type.Deposit {
        background: rgba(34, 197, 94, 0.2);
        color: #22c55e;
      }

      .event-type.Withdraw {
        background: rgba(249, 115, 115, 0.2);
        color: #f97373;
      }

      .event-type.sold {
        background: rgba(34, 197, 94, 0.2);
        color: #22c55e;
      }

      .event-type.purchased {
        background: rgba(59, 130, 246, 0.2);
        color: #3b82f6;
      }

      .event-type.listed {
        background: rgba(251, 191, 36, 0.2);
        color: #fbbf24;
      }

      .event-type.NFTLocked {
        background: rgba(251, 191, 36, 0.2);
        color: #fbbf24;
      }

      .event-type.NFTUnlocked {
        background: rgba(59, 130, 246, 0.2);
        color: #3b82f6;
      }

      .wallet-link {
        color: var(--accent-cyan);
        text-decoration: none;
        font-family: monospace;
        font-size: 0.85rem;
      }

      .wallet-link:hover {
        text-decoration: underline;
      }

      .nft-link {
        color: var(--accent-blue);
        text-decoration: none;
        font-family: monospace;
        font-size: 0.85rem;
      }

      .nft-link:hover {
        text-decoration: underline;
      }

      .timestamp {
        color: var(--text-muted);
        font-size: 0.85rem;
      }

      .empty-state {
        text-align: center;
        padding: 3rem 1rem;
        color: var(--text-muted);
      }

      .empty-state-icon {
        font-size: 3rem;
        margin-bottom: 1rem;
      }
    </style>
  </head>
  <body>
    <header class="app-header">
      <div class="brand">
        <div class="brand-logo">üê±</div>
        <div>
          <div class="brand-title">Chunky's NFLAD Viewer</div>
        </div>
      </div>
      <nav class="main-nav">
        <a href="/" id="nav-wallet">Wallet</a>
        <a href="/top-holders.html" id="nav-top-holders">Top holders</a>
        <a href="/explorer.html" id="nav-explorer">Browse</a>
        <a href="/insights.html" id="nav-insights">Insights</a>
        <a href="/live-transactions.html" id="nav-live" class="active">Live</a>
        <a href="/faq.html" id="nav-faq">FAQ</a>
        <a href="/contact.html" id="nav-contact">Contact</a>
        <a href="/login.html" id="nav-account-link">Login</a>
      </nav>
    </header>
    <script src="/header.js"></script>

    <main class="app-main">
      <h1 class="page-title">Live NFL All Day Transactions</h1>
      <p class="page-subtitle">Real-time transactions via local Flow Light Node (seconds delay)</p>

      <div class="controls">
        <div class="status-indicator">
          <span class="status-dot" id="status-dot"></span>
          <span id="status-text">Connecting...</span>
        </div>
        <button class="btn btn-primary" id="btn-start">Start</button>
        <button class="btn" id="btn-stop">Stop</button>
        <button class="btn" id="btn-clear">Clear</button>
        <select class="btn" id="source-select" style="min-width: 180px;">
          <option value="lightnode" selected>üü¢ Light Node (real-time)</option>
          <option value="snowflake">üìä Snowflake (~45 min delay)</option>
          <option value="live">üîå WebSocket (experimental)</option>
          <option value="flow-rest">‚ö° Flow REST (unreliable)</option>
        </select>
        <span style="color: var(--text-muted); font-size: 0.85rem;">
          Showing <span id="count">0</span> transactions
        </span>
      </div>
      
      <div id="data-freshness-banner" style="display: none; padding: 0.75rem 1rem; background: rgba(251, 191, 36, 0.15); border: 1px solid rgba(251, 191, 36, 0.3); border-radius: 8px; margin-bottom: 1rem; font-size: 0.9rem;">
        <span style="color: #fbbf24;">‚ö†Ô∏è</span>
        <span id="freshness-text">Data freshness info</span>
      </div>

      <table class="transactions-table">
        <thead>
          <tr>
            <th>Time</th>
            <th>Type</th>
                    <th>Moment</th>
          <th>Seller</th>
          <th>Buyer</th>
            <th>Block</th>
          </tr>
        </thead>
        <tbody id="transactions-tbody">
          <tr>
            <td colspan="6" class="empty-state">
              <div class="empty-state-icon">üì°</div>
              <div>Click "Start" to begin monitoring live transactions</div>
            </td>
          </tr>
        </tbody>
      </table>
    </main>

    <script>
      const POLL_INTERVAL = 3000; // 3 seconds - Light node provides real-time data

      let isMonitoring = false;
      let pollInterval = null;
      let lastBlockHeight = null;
      let transactions = [];
      const MAX_TRANSACTIONS = 100;
      // Data source: 'lightnode' is real-time via local Flow node
      let dataSource = 'lightnode';
      let lastEventTimestamp = null;

      const statusDot = document.getElementById('status-dot');
      const statusText = document.getElementById('status-text');
      const btnStart = document.getElementById('btn-start');
      const btnStop = document.getElementById('btn-stop');
      const btnClear = document.getElementById('btn-clear');
      const sourceSelect = document.getElementById('source-select');
      const tbody = document.getElementById('transactions-tbody');
      const countEl = document.getElementById('count');
      const freshnessBanner = document.getElementById('data-freshness-banner');
      const freshnessText = document.getElementById('freshness-text');
      
      function updateFreshnessBanner(show, message) {
        if (show) {
          freshnessBanner.style.display = 'block';
          freshnessText.textContent = message;
        } else {
          freshnessBanner.style.display = 'none';
        }
      }

      function updateStatus(status, text) {
        statusDot.className = 'status-dot ' + status;
        statusText.textContent = text;
      }

      function formatTime(timestamp) {
        const date = new Date(timestamp);
        const now = new Date();
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / (1000 * 60));
        const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
        const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
        
        // Show relative time + actual time
        let relTime;
        if (diffDays > 0) {
          relTime = `${diffDays}d ago`;
        } else if (diffHours > 0) {
          relTime = `${diffHours}h ago`;
        } else if (diffMins > 0) {
          relTime = `${diffMins}m ago`;
        } else {
          relTime = 'just now';
        }
        
        const timeStr = date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        const dateStr = date.toLocaleDateString([], {month: 'short', day: 'numeric'});
        return `<span title="${date.toLocaleString()}">${relTime}<br><small style="color:var(--text-muted)">${dateStr} ${timeStr}</small></span>`;
      }

      function formatWallet(wallet, walletName) {
        if (!wallet) return '-';
        const displayName = walletName || (wallet.length > 10 ? wallet.slice(0, 6) + '...' + wallet.slice(-4) : wallet);
        return `<a href="/?wallet=${encodeURIComponent(wallet)}" class="wallet-link" title="${wallet}">${displayName}</a>`;
      }

      function formatMoment(nftId, moment) {
        if (!nftId) return '-';
        if (moment && moment.playerName) {
          const parts = [moment.playerName];
          if (moment.teamName) parts.push(moment.teamName);
          if (moment.tier) parts.push(`(${moment.tier})`);
          const display = parts.join(' ‚Ä¢ ');
          return `<a href="https://nflallday.com/moments/${nftId}" target="_blank" class="nft-link" title="NFT ID: ${nftId}">${display}</a>`;
        }
        // Fallback to NFT ID if no moment data
        const short = nftId.length > 12 ? nftId.slice(0, 8) + '...' + nftId.slice(-4) : nftId;
        return `<a href="https://nflallday.com/moments/${nftId}" target="_blank" class="nft-link">${short}</a>`;
      }

      function addTransaction(tx) {
        // Add to beginning of array
        transactions.unshift(tx);
        
        // Keep only last MAX_TRANSACTIONS
        if (transactions.length > MAX_TRANSACTIONS) {
          transactions = transactions.slice(0, MAX_TRANSACTIONS);
        }

        renderTransactions();
      }

      function renderTransactions() {
        if (transactions.length === 0) {
          tbody.innerHTML = `
            <tr>
              <td colspan="6" class="empty-state">
                <div class="empty-state-icon">üì°</div>
                <div>No transactions yet. Waiting for activity...</div>
              </td>
            </tr>
          `;
          countEl.textContent = '0';
          return;
        }

        countEl.textContent = transactions.length;

        tbody.innerHTML = transactions.map((tx, idx) => {
          // Determine event type styling
          let eventClass = tx.type.toLowerCase();
          let eventLabel = tx.type;
          
          // Map event types to better labels
          if (tx.type === 'Sold') {
            eventClass = 'sold';
            eventLabel = 'Sold';
          } else if (tx.type === 'Purchased') {
            eventClass = 'purchased';
            eventLabel = 'Purchased';
          } else if (tx.type === 'Listed') {
            eventClass = 'listed';
            eventLabel = 'Listed';
          }
          
          return `
            <tr class="${idx === 0 ? 'new' : ''}">
              <td class="timestamp">${formatTime(tx.timestamp)}</td>
              <td><span class="event-type ${eventClass}">${eventLabel}</span></td>
              <td>${formatMoment(tx.nftId, tx.moment)}</td>
              <td>${formatWallet(tx.from, tx.sellerName)}</td>
              <td>${formatWallet(tx.to, tx.buyerName)}</td>
              <td class="timestamp">${tx.blockHeight}</td>
            </tr>
          `;
        }).join('');
      }

      async function fetchLatestEvents() {
        try {
          // Light Node source (real-time via local Flow node)
          if (dataSource === 'lightnode') {
            const eventsRes = await fetch('/api/lightnode-events?limit=50');
            
            if (!eventsRes.ok) {
              throw new Error(`Failed to fetch from light node: HTTP ${eventsRes.status}`);
            }
            
            const eventsData = await eventsRes.json();
            if (!eventsData.ok) {
              throw new Error(eventsData.error || 'Failed to fetch events');
            }
            
            const events = eventsData.events || [];
            
            // Light node proxies to upstream, so no sync delay to worry about
            updateFreshnessBanner(false);
            
            // Filter out events we've already seen
            const seenTxIds = new Set(transactions.map(t => t.txId).filter(Boolean));
            const newEvents = events.filter(tx => !tx.txId || !seenTxIds.has(tx.txId));
            
            // Process new events - reverse order so newest ends up on top
            for (let i = newEvents.length - 1; i >= 0; i--) {
              addTransaction(newEvents[i]);
            }
            
            const blockRange = eventsData.startHeight && eventsData.endHeight 
              ? `${eventsData.startHeight}-${eventsData.endHeight}` 
              : eventsData.latestBlockHeight;
            const statusText = events.length > 0 
              ? `Light Node: ${events.length} events in blocks ${blockRange}` 
              : `Light Node: Watching blocks ${blockRange}...`;
            updateStatus('active', statusText);
            return;
          }
          
          // Live WebSocket source (real-time, ~seconds delay)
          // Falls back to Snowflake if no live events
          if (dataSource === 'live') {
            const sinceParam = lastEventTimestamp ? `&since=${lastEventTimestamp.toISOString()}` : '';
            const eventsRes = await fetch(`/api/live-events?limit=100${sinceParam}`);
            
            if (!eventsRes.ok) {
              throw new Error(`Failed to fetch live events: HTTP ${eventsRes.status}`);
            }
            
            const eventsData = await eventsRes.json();
            if (!eventsData.ok) {
              throw new Error(eventsData.error || 'Failed to fetch events');
            }
            
            let events = eventsData.events || [];
            
            // If no live events and this is the first fetch, bootstrap from Snowflake
            if (events.length === 0 && transactions.length === 0) {
              console.log("No live events yet, fetching from Snowflake to bootstrap...");
              try {
                const snowflakeRes = await fetch('/api/recent-events-snowflake?limit=50&hours=1');
                if (snowflakeRes.ok) {
                  const snowflakeData = await snowflakeRes.json();
                  if (snowflakeData.ok && snowflakeData.events) {
                    events = snowflakeData.events;
                    updateFreshnessBanner(true, `Showing recent Snowflake data while waiting for live events...`);
                  }
                }
              } catch (err) {
                console.error("Failed to bootstrap from Snowflake:", err);
              }
            } else if (eventsData.wsConnected) {
              updateFreshnessBanner(false);
            } else {
              updateFreshnessBanner(true, 'WebSocket disconnected - reconnecting...');
            }
            
            // Filter out events we've already seen
            const seenTxIds = new Set(transactions.map(t => t.txId).filter(Boolean));
            const newEvents = events.filter(tx => !tx.txId || !seenTxIds.has(tx.txId));
            
            // Process new events - reverse order so newest ends up on top after unshift
            // (events come sorted newest-first, but unshift reverses that)
            for (let i = newEvents.length - 1; i >= 0; i--) {
              addTransaction(newEvents[i]);
            }
            
            // Update last seen timestamp
            if (events.length > 0) {
              const latestTime = new Date(Math.max(...events.map(tx => new Date(tx.timestamp).getTime())));
              if (!lastEventTimestamp || latestTime > lastEventTimestamp) {
                lastEventTimestamp = latestTime;
              }
            }
            
            const statusText = eventsData.wsConnected 
              ? `Live: ${eventsData.cacheSize} cached${transactions.length > 0 ? `, showing ${transactions.length}` : ''}` 
              : 'Live: Reconnecting...';
            updateStatus(eventsData.wsConnected ? 'active' : 'error', statusText);
            return;
          }
          
          // Snowflake source (~30-90 min delay)
          if (dataSource === 'snowflake') {
            const hoursAgo = 2; // Get events from last 2 hours 
            const eventsRes = await fetch(`/api/recent-events-snowflake?limit=100&hours=${hoursAgo}`);
            
            if (!eventsRes.ok) {
              throw new Error(`Failed to fetch events from Snowflake: HTTP ${eventsRes.status}`);
            }
            
            const eventsData = await eventsRes.json();
            if (!eventsData.ok) {
              throw new Error(eventsData.error || 'Failed to fetch events');
            }
            
            const events = eventsData.events || [];
            
            // Show data freshness banner for Snowflake - only warn if unusually delayed
            if (eventsData.dataAgeHours !== null && eventsData.dataAgeHours !== undefined) {
              const ageHours = eventsData.dataAgeHours;
              const ageMins = Math.round(ageHours * 60);
              if (ageHours > 2) {
                updateFreshnessBanner(true, `‚ö†Ô∏è Data is ${ageHours.toFixed(1)} hours old. Snowflake may be experiencing unusual delays.`);
              } else {
                // Under 2 hours is normal for Snowflake - no warning needed
                updateFreshnessBanner(false);
              }
            } else if (events.length === 0) {
              updateFreshnessBanner(true, `No events found in the last ${hoursAgo} hours.`);
            }
            
            // Filter out events we've already seen by transaction ID (more reliable than timestamp)
            const seenTxIds = new Set(transactions.map(t => t.txId).filter(Boolean));
            const newEvents = events.filter(tx => {
              // Skip if we've already seen this transaction
              if (tx.txId && seenTxIds.has(tx.txId)) return false;
              
              // Also check by timestamp if no txId
              if (!lastEventTimestamp) return true;
              const txTime = new Date(tx.timestamp);
              return txTime > lastEventTimestamp;
            });
            
            // Process new events - reverse order so newest ends up on top after unshift
            for (let i = newEvents.length - 1; i >= 0; i--) {
              addTransaction(newEvents[i]);
            }
            
            // Update last seen timestamp
            if (events.length > 0) {
              const latestTime = new Date(Math.max(...events.map(tx => new Date(tx.timestamp).getTime())));
              if (!lastEventTimestamp || latestTime > lastEventTimestamp) {
                lastEventTimestamp = latestTime;
              }
              
              // Calculate how old the most recent event is
              const ageMs = Date.now() - latestTime.getTime();
              const ageHours = Math.floor(ageMs / (1000 * 60 * 60));
              const ageMins = Math.floor((ageMs % (1000 * 60 * 60)) / (1000 * 60));
              const ageStr = ageHours > 0 ? `${ageHours}h ${ageMins}m` : `${ageMins}m`;
              
              updateStatus('active', `Snowflake: ${events.length} events (newest: ${ageStr} ago)`);
            } else {
              updateStatus('active', `Snowflake: No events found in last ${hoursAgo} hours`);
            }
            return;
          }
          
          // Flow REST API (live but often unreliable)
          if (dataSource !== 'flow-rest') return;
          
          // Hide freshness banner for Flow API (it's supposed to be live)
          updateFreshnessBanner(false);
          
          // Flow REST API approach
          // Get latest block first using our proxy
          const blockRes = await fetch('/api/flow-latest-block');
          if (!blockRes.ok) {
            const errorText = await blockRes.text();
            throw new Error(`Failed to get latest block: HTTP ${blockRes.status} - ${errorText.substring(0, 100)}`);
          }
          
          const blockData = await blockRes.json();
          if (!blockData.ok) {
            throw new Error(blockData.error || 'Failed to get latest block');
          }
          
          const currentBlockHeight = blockData.height;

          if (!lastBlockHeight || lastBlockHeight < 0) {
            // Start from current block (only look forward)
            lastBlockHeight = currentBlockHeight;
          }
          
          // Ensure we don't query with invalid heights
          if (currentBlockHeight <= 0) {
            throw new Error("Invalid block height received from server");
          }
          
          if (lastBlockHeight >= currentBlockHeight) {
            // No new blocks, just update status
            updateStatus('active', `Monitoring (Block ${currentBlockHeight}, no new blocks)`);
            return;
          }
          
          // Limit to small block ranges to avoid 500 errors
          const maxBlockRange = 2;
          const queryEndHeight = Math.min(currentBlockHeight, lastBlockHeight + maxBlockRange);

          // Fetch events from lastBlockHeight to queryEndHeight using our proxy
          const eventsRes = await fetch(
            `/api/flow-events?start_height=${lastBlockHeight}&end_height=${queryEndHeight}`
          );

          if (!eventsRes.ok) {
            const errorText = await eventsRes.text();
            throw new Error(`Failed to fetch events: HTTP ${eventsRes.status} - ${errorText.substring(0, 100)}`);
          }

          const eventsData = await eventsRes.json();
          if (!eventsData.ok) {
            throw new Error(eventsData.error || 'Failed to fetch events');
          }

          const events = eventsData.events || [];

          // Process new events - reverse order so newest ends up on top
          for (let i = events.length - 1; i >= 0; i--) {
            addTransaction(events[i]);
          }

          // Update lastBlockHeight to where we queried
          lastBlockHeight = queryEndHeight;
          updateStatus('active', `Monitoring (Block ${currentBlockHeight}, queried ${lastBlockHeight}-${queryEndHeight})`);
        } catch (err) {
          console.error('Error fetching events:', err);
          const errorMsg = err.message || 'Unknown error';
          updateStatus('error', 'Error: ' + errorMsg.substring(0, 50));
          // Don't stop monitoring on error, just log it
        }
      }

      function startMonitoring() {
        if (isMonitoring) return;
        
        isMonitoring = true;
        updateStatus('active', 'Starting...');
        btnStart.disabled = true;
        btnStop.disabled = false;

        // Fetch immediately
        fetchLatestEvents();

        // Then poll every POLL_INTERVAL
        pollInterval = setInterval(fetchLatestEvents, POLL_INTERVAL);
      }

      function stopMonitoring() {
        if (!isMonitoring) return;
        
        isMonitoring = false;
        updateStatus('', 'Stopped');
        btnStart.disabled = false;
        btnStop.disabled = true;

        if (pollInterval) {
          clearInterval(pollInterval);
          pollInterval = null;
        }
      }

      function clearTransactions() {
        transactions = [];
        renderTransactions();
      }

      btnStart.addEventListener('click', startMonitoring);
      btnStop.addEventListener('click', stopMonitoring);
      btnClear.addEventListener('click', clearTransactions);
      
      if (sourceSelect) {
        sourceSelect.addEventListener('change', () => {
          dataSource = sourceSelect.value;
          // Clear transactions and reset state when switching sources
          transactions = [];
          lastEventTimestamp = null;
          lastBlockHeight = null;
          renderTransactions();
          updateFreshnessBanner(false);
          if (isMonitoring) {
            // Restart monitoring with new source
            stopMonitoring();
            setTimeout(startMonitoring, 100);
          }
        });
      }
      
      btnStop.disabled = true;

      // Auto-start on page load
      startMonitoring();
    </script>
  </body>
</html>

